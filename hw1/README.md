## Poisson Problem with Finite Element Method

To build this program, you must first install the dependency yaml-cpp.  On our system, we put it in ~/SoftwareLibraries/yaml-cpp.  We built it and then dropped a link pointing to libyaml-cpp.a into the directory ~/SoftwareLibraries/lib.  Note that this link must be a hard link to work on CentOS 7 / Odyssey! A soft link works fine on Ubuntu but fails on CentOS.

The makefile always needs one environment variables on a default Linux system, including Odyssey: INCLUDE_USR points to ~/SoftwareLibraries (or wherever you have it on your system).  This is used to derive both the include and library directories.

In addition, you can optionally provide a directory BOOST_DIR.  This is not necessary on Odyssey if you first load the module for Boost 1_69_0.

To build on Odyssey, first load the modules for gcc 8.2; LAPACK / BLAS; and Boost 1_69_0.  Clone our repo into e.g. hw1 or Poisson and then run make.  It should build cleanly if the dependencies are all there.

One instance of the Poisson Problem is described by a YAML configuration file.  Please see the example files example_1.yml through example_4.yml.  The first 3 are the examples suggested in the assignment.  The fourth one is a more interesting case with u(x)  = sin(x), u''(x) = -sin(x) and f(x) = sin(x).  Appropriate boundary conditions h = -cos(0) = -1 and g = sin(1) = 0.84147098 were also added.  There is a choice to define the force vector as either a hard coded vector (forceType = "VECTOR") and a function (forceType = "FUNCTION").  The first three examples originally used vectors then switched to functions; this makes it easier to increase n.  Example 4 only using function because it's too tedious to type in a bunch of trig function values.

PoissonExamples (hpp and cpp) defines functions for the force F(x) and solution U(x) for these four examples.  These support both input of the force vector via a function as well as automated testing.  We didn't add the capability to write a function as a string to be compiled dynamically because it would have added too much complexity.

The bulk of the calculations are done in the PoissonFiniteElement class.  It is constructed using a string that points to a file name of the YAML configuration file.  All calculations of the finite element method closely follow the treatment in "The Finite Element Method" by Hughes.  The calculations of the local (element)	 $K_{e}$ and $F_{e}$ are currently specialized for piecewise linear interpolation.  In this case, Gaussian Quadrature reduces to the midpoint method, and simple formulas come out.  These are in the Hughes book and were used.  The code framework is flexible enough that we could drop in a modular Gaussian Quadrature routine later, but given that we are only using piecewise linear splines it was simpler to start with the explicit formulas.

There are separate methods to build up the K matrix (assemble_K) and the F vector that is the right hand side of the equation (assemble_F).  A third method, solve(), solves for U once K and F are available.  The current version is simple and doesn't take advantage of the symmetric tridiagonal structure of K.  Instead, K is naively stored as a dense n by n matrix.  We solve for U using the most generic LAPACK routine DGESV, which solves a dense system using Gaussian Elimination.  If we wanted to solve this problem in earnest for a large data set, by far the biggest improvement we could make would be to specialize the storage of K and to solve using the optimized LAPACK function.  My copy of the Users' Guide suggests SPTSV is designed for symmetric Hermitian positive definite tridiagonal systems.  There is also SPBSV for symmetric positive definite banded if we increased the bandwidth, e.g. with a different basis.

The LAPACK functions were called using a C++ wrapper function.  This was provided in the examples for Applied Math 225; it was not original.  (It's only a few lines of simple code).  One important detail is that while some data in the PoissonProblem class was stored as a C++ vector (e.g. the mesh grid), all matrices and vectors that need to interface with LAPACK were stored as arrays of doubles.  Large arrays were created with operator new and deleted in the destructor to avoid memory leaks.  And arrays were stored in column major order to match Fortran conventions.  (It happens not to matter here because K is symmetric, but in general this is a crucial detail.)  The wrappers to LAPACK functions are in LinearSolve (hpp and cpp).

The main program is called poisson.cpp.  It runs tests on all four examples, and indicates the results.  The 3 simple tests were run with n=8 to allow the vectors to be entered in explicitly.  The more interesting test with u(x) = sin(x) was run with n=128, which gave excellent results (error of than 8E-7).  A possible improvement would be to accept a command line argument and process the named configuration file.

The Makefile conforms to the example shown in class.  Some care was taken to add line breaks and tabs so the resulting commands are legible on the screen.  The Makefile was originally prototyped as an "idiot proof" manual file, manual.mk.  This allowed us to isolate variables when trouble shooting.  Once the manual version worked for the first three files, it was automated into config.mk, Makefile.dep and Makefile.  We've left the original because it makes it easier to see what's going on and is a good backup if something breaks.

All functions were commented with tags compatible with Doxygen.  Documentation was automatically generated.  The configuration file is in the repository, but the latex and html working directories were excluded to avoid clutter.  You can quickly generate documentation on your local repository by running doxygen poisson.config.